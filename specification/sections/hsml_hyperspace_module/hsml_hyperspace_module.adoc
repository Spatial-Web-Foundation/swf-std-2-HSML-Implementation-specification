== HSML Hyperspace Module

=== Introduction

The Hyperspace Module defines the structural foundation for representing spatial relationships in HSML.
It realizes the *HYPERSPACE* concept of <<ieee-p2874,clause="6.2.1">>, which defines a hyperspace as:

[quote]
____
A set whose elements are related by a formal notion of path, satisfying identity and composition laws.
Paths may be abstract, as long as they can be traversed in a fashion akin to the paths between points in familiar spaces.
____

This abstract definition is intentionally broad. It allows HSML to treat a wide range of structures—
geographic coordinates, social networks, organizational hierarchies, logical states, numeric values, or semantic concepts—
under one unifying abstraction. Hyperspaces ensure that Domains are not just collections of entities, but *structured environments*
in which relationships such as adjacency, connectivity, reachability, and composition can be explicitly represented and navigated.

Crucially, Hyperspaces in HSML are *made operational by explicit mappings*:

* *Elements* → classes or datatypes (e.g., `geo:Geometry`, `cell:Cell`, `xsd:integer`).
* *Arrows* (atomic steps) → RDF properties or edge classes (e.g., `graph:edge`, `cell:adjacentTo`).
* *Paths* (compositions) → explicit path resources (e.g., `graph:Route`, `cell:CellChain`) or SPARQL property paths.
* *Operations* → instances of `hspace:Operation` bound to these mappings, validated via SHACL profiles.

Through these mappings, navigation (neighbors, reachability, path composition) and operations (distance, similarity, routing)
are not hard-coded into the ontology, but arise from *declared structures* that can be validated, extended, and executed.
This makes the Hyperspace Module both *abstractly universal* and *practically concrete*.

Because the Spatial Web encompasses diverse domains, the Hyperspace Module is *modular by design*.
The core module defines only the minimum semantics common to *all* Hyperspaces: elements, arrows, paths, and universal properties.
Specializations provide richer semantics:

* GraphSpace — connectivity and networks.
* CellularSpace — grids and tessellations.
* VectorSpace — coordinate systems and geometries.
* MetricSpace — distance and similarity.
* Datatype Hyperspaces — value domains such as numbers, strings, colors, or tensors.

This modular structure allows implementers to import only what they need while preserving interoperability.
Namespaces mirror this pattern: the core vocabulary resides in the `hyperspace#` namespace, while each specialization
occupies its own sub-namespace under `hyperspace/`.

In this way, the Hyperspace Module provides both a *universal foundation* and a *scalable framework for extension*,
making it a cornerstone of HSML and of the Spatial Web as a whole.

==== Navigation by Mapping

Navigation in a Domain’s Hyperspace is not hard-coded; it is *achieved by mapping abstract constructs to RDF structures*:

* **Elements**
  - Mapped to an RDF class (e.g., `graph:Node`, `cell:Cell`) or a datatype (e.g., `geosparql:wktLiteral`, `tensor:ArrayLiteral`).
  - Optionally bound via a `hyperspace:spatialProperty` (e.g., `geo:hasGeometry`, `hspace:cell`) to point to the actual value.

* **Arrows (atomic steps)**
  - Mapped to an RDF property (e.g., `graph:edge`, `cell:adjacentTo`) connecting valid element instances.
  - Alternatively represented as a reified edge class with `hspace:source` and `hspace:target`, or as RDF-star annotated triples for weighted/labeled edges.

* **Paths (compositions)**
  - *Implicit:* expressed through SPARQL property paths over the declared arrow property (e.g., `(graph:edge)+` for reachability).
  - *Explicit:* represented as RDF resources (e.g., `graph:Route`, `cell:CellChain`) with ordered `hspace:step`, `hspace:startsAt`, and `hspace:endsAt` properties.

These mappings allow core navigation queries such as:
- **Neighbors:** `?a hspace:hasArrowType ?b`
- **Reachability:** `ASK { ?a ( ?arrow )+ ?b }`
- **Path Extraction:** select explicit path resources linking two elements.

Thus, navigation is universally defined but concretely realized through the mapping pattern chosen for each Hyperspace specialization.

==== Design Decision: Paths with Literal Elements (Generalized)

In some Hyperspaces, `hspace:hasElementType` is a **datatype** (e.g., `xsd:string`, JSON literals, tensors, WKT).
Because RDF literals cannot be subjects, arrows and paths **CANNOT** be expressed as direct triples between literals.
This decision specifies **general, profile-able mapping patterns** and properties that work for *any* element kind
(class- or datatype-based) and *any* path representation. (We include a `geo:Geometry` example purely illustratively.)

===== Normative Principles

*P1 — No literal subjects*:: Arrows/paths SHALL NOT rely on triples requiring a literal subject.

*P2 — Arrow-driven navigation*:: Navigation semantics (neighbors, reachability, composition) SHALL be derived from
the Hyperspace’s **arrow mapping** (predicate edge or reified edge), not from any serialized path payload.

*P3 — Two interoperable mappings*:: Profiles MAY choose either **Value-Node** (recommended) or **Literal-End** mappings.
Both are first-class in HSML; the choice MUST be advertised by the Hyperspace’s mapping properties.

*P4 — Path resource portability*:: Paths SHOULD be first-class resources (subclasses of `hspace:Path`) so implementations
can attach metadata (cost, provenance) and validate steps with SHACL—independent of element representation.

===== Patterns

*Pattern L1 — Value-Node (RECOMMENDED)*::
Materialize each element as a **resource node** (instances of a class declared by `hspace:hasElementType`), and carry the
raw value via a datatype property (`hspace:elementValue` or a domain-standard property). Arrows are normal object properties
(`hspace:arrowProperty`) or reified edge instances (`hspace:arrowClass` with `hspace:arrowSource` / `hspace:arrowTarget`).
Paths use `hspace:startsAt` / `hspace:endsAt` and optional `hspace:step`.

*Pattern L2 — Literal-End (SUPPORTED)*::
Keep elements as **literals** (i.e., `hspace:hasElementType` is a datatype). Represent arrows as **reified edge resources**
with **literal endpoints** (`hspace:arrowSourceValue`, `hspace:arrowTargetValue`). Represent paths as **resources** whose
endpoints/steps are **literal-valued** (`hspace:startsAtValue``, `hspace:endsAtValue`, `hspace:stepList` or `hspace:pathLiteral`).

[NOTE]
====
L1 enables property-path traversals and richer per-element metadata; L2 avoids node materialization at the cost of reified
navigation. Choose per data-volume, query needs, and tooling.
====

==== Separation of Domain and Hyperspace

*Domain* provides identity and contextual scope.
*Hyperspace* attached to a Domain defines how its entities relate.
This separation allows the same Domain to be interpreted under different logics (graph, metric, cellular, temporal) without altering identity.

==== Universal Operations

A small algebra applies to all Hyperspaces:

* *Identity* — every element is reachable from itself.
* *Reachability* — test existence of a path between elements.
* *Path Composition* — concatenate two compatible paths.
* *Subspace Formation* — restrict a Hyperspace to a subset of elements and induced arrows.

Specialized Hyperspaces extend this with richer operations (e.g., shortest path, similarity metrics).


==== Modularity and Namespaces

Namespaces follow a predictable hierarchy:

* Core: identifier:[https://www.spatialwebfoundation.org/ns/hsml/hyperspace#]
* GraphSpace: identifier:[https://www.spatialwebfoundation.org/ns/hsml/hyperspace/graph#]
* CellularSpace: identifier:[https://www.spatialwebfoundation.org/ns/hsml/hyperspace/cell#]
* VectorSpace: identifier:[https://www.spatialwebfoundation.org/ns/hsml/hyperspace/vector#]
* MetricSpace: identifier:[https://www.spatialwebfoundation.org/ns/hsml/hyperspace/metric#]
* Datatype Hyperspaces: identifier:[https://www.spatialwebfoundation.org/ns/hsml/hyperspace/datatype#]

This structure ensures clarity, modularity, and extensibility.

By organizing namespaces in this way, several goals are achieved:

* **Clarity** — It is immediately clear whether a term belongs to the core Hyperspace abstraction or a specialized extension.

* **Modularity** — Implementers can import only the extensions they need, keeping systems lightweight.

* **Extensibility** — New families of Hyperspaces (e.g., probabilistic space, tensor spaces, state-machine spaces) can be introduced
  simply by assigning them new sub-namespaces, without disrupting existing definitions.

* **Best Practices** — This mirrors established approaches in ontology engineering, where namespaces are stable,
  descriptive, and composable.

In effect, the namespace design mirrors the architecture of Hyperspaces themselves: a simple core scaffold that
can be specialized into many forms, each with its own dedicated space but all interoperable under a common root.

==== Hyperspace of Hyperspaces

A Hyperspace is itself an Entity and may serve as an element within another Hyperspace.
This enables **Hyperspaces of Hyperspaces**, supporting higher-order composition:

* **Systems-of-Systems** — city networks combined into a national network.
* **Federations** — regional grids aggregated into a global monitoring system.
* **Holarchies** — nested Hyperspaces reflecting P2874’s holonic design principles.

This higher-order capability is essential for modeling federated and polycentric structures in the Spatial Web.

==== Time as an Extension

Temporal semantics are not universal and are therefore modeled as extensions.
Arrows and paths may carry temporal annotations (`time:validDuring`, `time:hasDuration`) using OWL-Time.
Profiles may define spatio-temporal Hyperspaces when time is central to navigation and reasoning.

==== Identity and Governance

Every Hyperspace is identified by a **Spatial Web Identifier (SWID)** conformant with W3C DID Core.
This ensures resolvability and governance.
While governance logic is external, the identifier anchors policies, credentials, and trust enforcement.

==== Validation Through Profiles

Constraints are expressed via **SHACL profiles**, not fixed in OWL.
Profiles may restrict element types, adjacency properties, or valid transitions, providing rigor in specific
deployments while preserving generality in the core.

*Summary:*

The Hyperspace Module defines elements, arrows, paths, and operations as a minimal universal abstraction.
By mapping these to RDF constructs, navigation and reasoning are enabled consistently across all domains.
SHACL profiles enforce structural integrity, while modular namespaces and higher-order composition provide extensibility.
Together, these design decisions make the Hyperspace Module a cornerstone of HSML and the Spatial Web.


=== Normative Classes

This clause provides the normative definitions for the classes of the **Hyperspace Module**.

==== Summary of Hyperspace Module Classes

.Summary of Hyperspace Module Classes
[cols="1,3",options="header"]
|===
| Class | Description

| <<hsml-hyperspace,hspace:Hyperspace>>
| Domain-attached structural abstraction that declares element, arrow, and path *types* and optional mappings for navigation and operations.

| <<hspace-path,hspace:Path>>
| First-class representation of composed paths (finite compositions of arrows); may carry endpoints, ordered steps, and serialized path values.

| <<hspace-operation,hspace:Operation>>
| Declarative operation bound to a Hyperspace (e.g., reachability, routing, metric evaluation), referencing the mappings it consumes.

| <<hspace-hyperspace-of-hyperspace,hspace:HyperspaceOfHyperspace>>
| Higher-order space whose elements are themselves Hyperspaces; supports federation, holarchies, and systems-of-systems.
|===

include::hsml_hyperspace.adoc[leveloffset=+1]

include::hsml_path.adoc[leveloffset=+1]

include::hsml_operation.adoc[leveloffset=+1]

include::hsml_hyperspace_of_hyperspace.adoc[leveloffset=+1]
