== Architectural Principles and Design Rationale

This clause describes the architectural principles underlying the HSML Activity Module. These principles are _informative_ and not required for conformance; however, understanding them is recommended to ensure robust and correct implementations.

=== The Schema/Instance Pattern: Enabling Scalable Governance

A fundamental principle of this standard is the strict separation between the _definition_ of an activity and the _record of its execution_. This separation is realized through two distinct HSML classes:

* `act:ActivitySchema` — A reusable, design-time template that specifies the type of action, its required inputs, expected outputs, and the conditions under which it is valid.
* `act:Activity` — An execution-time entity representing a single, concrete, stateful instance of an `act:ActivitySchema` performed by a specific agent at a specific time.

This separation is a cornerstone of governance and scalability within the Spatial Web. It enables a "trust-by-reference" model where an orchestration engine can validate an action with high efficiency. Rather than analyzing the internal logic of the action itself, the validator only needs to check whether the `act:Activity` references an `act:ActivitySchema` from an approved registry. This decouples the high-level, infrequent work of policy definition (approving schemas) from the high-frequency, operational work of validation (checking activities), producing a highly scalable and secure governance framework.

=== The Parameter/Binding Pattern: Achieving Contextual Reusability

Complementing the schema/instance pattern is the separation of abstract parameters from their concrete values. This is achieved through the `act:Variable` and `act:VariableBinding` classes.

* `act:Variable` is used within an `act:ActivitySchema` to define a placeholder for an input or output (e.g., "target_location"), including its name, description, and constraints, but no specific value.
* `act:VariableBinding` is used within an `act:Activity` to connect a specific `act:Variable` from the schema to a concrete value (e.g., linking "target_location" to a specific address).

This design allows `act:ActivitySchema` definitions to be generic and broadly reusable. A single schema for "TransferAsset" can be instantiated in thousands of different `act:Activity` instances, each using `act:VariableBinding` to supply the concrete assets and accounts for a specific transaction. This promotes standardization while ensuring every `act:Activity` is a complete, self-contained, and auditable record.

A key architectural decision in this pattern is how a `VariableBinding` references its corresponding `Variable`. This model mandates the use of the `Variable`'s locally unique `schema:identifier` (e.g., `"targetLocation"`) rather than its global URI. This choice is deliberate and provides two main benefits:

. *Consistency*: It establishes a single, predictable pattern across the entire Activity model. Just as `act:DataLink` uses local identifiers to wire steps together within a composite schema, `act:VariableBinding` uses the same mechanism to bind values at runtime. This consistency simplifies implementation and makes the model easier to learn.
. *Portability*: It treats the `ActivitySchema` as a true, self-contained template. An `Activity` instance is bound to the _role_ a variable plays within the schema (its local identifier), not to a rigid, globally unique URI. This decouples the execution record from the schema definition, allowing the schema to be versioned or reused more flexibly without invalidating existing activity instances.

This approach requires the processing engine to resolve the reference by looking up the identifier within the context of the activity's schema. This is a standard pattern and a worthwhile trade-off for the significant gains in consistency, portability, and developer experience.

=== The Composite Model: First-Class Workflows

For composite (multi-step) activities, a simple list of sub-activities is insufficient. A robust model must also describe the *sequence of steps*, the *flow of data* between them, and the *control flow logic* (e.g., conditional branches). The Activity Module addresses this by elevating the core components of a workflow to be first-class citizens:

* `act:ActivityStep`: A node in the workflow graph. It represents a discrete stage of execution and is a rich, self-describing object.
* `act:DataLink`: An edge in the workflow graph. It represents the explicit flow of data from one step's output to another's input.

The decision to model `act:ActivityStep` and `act:DataLink` as distinct `owl:Class` instances, rather than simple properties, is a cornerstone of this architecture. It makes the entire workflow—its structure, logic, and data flow—explicit, addressable, and governable.

This design allows for sophisticated patterns:
* *Documentable and Addressable Steps*: Each `act:ActivityStep` can have a human-readable `schema:name` and `schema:description`, making the workflow self-documenting. It is given a simple, local `schema:identifier` (e.g., "validate-user") for easy reference by `act:DataLink` instances.
* *Conditional Control Flow*: An `act:ActivityStep` can carry its own `core:Condition`. This enables powerful, declarative control flow, such as an "if/then/else" branch, where the execution of a step depends on the outcome of a formal condition.
* *Governable and Self-Describing Data Flow*: Because a `act:DataLink` is a first-class entity, it can be documented with its own `schema:name` and `schema:description` (e.g., "Pass User ID to Validator"). Furthermore, metadata can be attached directly to the data transfer itself, allowing for quality-of-service requirements (e.g., `ex:maxLatency`), security classifications, or even a `core:Condition` to enforce a policy on the data link.

This approach transforms a simple sequence of tasks into a fully governable, introspectable, and self-describing graph of actions that can be validated, audited, and reused with high fidelity.

=== The Generic Condition Model: Future-Proofing Logic

The HSML architecture separates semantic intent from technical implementation. This is exemplified by the `core:Condition` model, defined in the HSML Core Module and used extensively by this Activity Module for properties like `act:hasPrecondition`, `act:hasEffect`, and for enabling conditional logic on an `act:ActivityStep`.

The `core:Condition` class is abstract; it represents the idea that a condition exists without specifying _how_ that condition must be evaluated. The actual evaluation logic is delegated to concrete subclasses, such as `core:SHACLCondition` or `core:SPARQLCondition`. This architectural choice is a powerful future-proofing mechanism. By having models reference the abstract `core:Condition`, the standard is not locked into any single validation technology. New condition types can be introduced in the future without requiring breaking changes to the core models, ensuring the long-term relevance and extensibility of the standard.

=== Domain-Specific Governance of Referenced Schemas

A core tenet of the Spatial Web's architecture is that domains can apply *local, context-specific governance* to universal, standardized `act:ActivitySchema` definitions without modifying the original schema. This is achieved by separating the activity's definition from the rules governing its execution within a domain. The primary mechanism for enforcing these domain-specific rules is the requirement of a domain-specific *CREDENTIAL*.

A Domain Authority (DA) can incorporate a universal schema by reference and then configure its domain policies to require that any agent performing the activity must present a specific credential. This model ensures that while the schema remains a universal standard, its execution is always subject to the explicit, verifiable, and non-negotiable rules of the domain in which it is performed.